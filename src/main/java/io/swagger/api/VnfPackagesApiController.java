package io.swagger.api;

import io.swagger.model.Body;
import io.swagger.model.Body1;
import io.swagger.model.Body2;
import io.swagger.model.Body3;
import io.swagger.model.InlineResponse2001;
import io.swagger.model.InlineResponse400;
import org.springframework.core.io.Resource;
import io.swagger.model.VnfPackagesVnfPkgInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.annotations.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.constraints.*;
import javax.validation.Valid;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.List;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2020-04-01T18:31:17.078Z")

@Controller
public class VnfPackagesApiController implements VnfPackagesApi {

    private static  Logger log = LoggerFactory.getLogger(VnfPackagesApiController.class);

    private final ObjectMapper objectMapper;

    private final HttpServletRequest request;

    @org.springframework.beans.factory.annotation.Autowired
    public VnfPackagesApiController(ObjectMapper objectMapper, HttpServletRequest request) {
        this.objectMapper = objectMapper;
        this.request = request;
    }

    public ResponseEntity<List<VnfPackagesVnfPkgInfo>> vnfPackagesGet(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Content-Types that are acceptable for the response. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "Attribute-based filtering expression according to clause 5.2 of ETSI GS NFV SOL 013. The NFVO shall support receiving this parameter as part of the URI query string. The OSS/BSS may supply this parameter. All attribute names that appear in the VnfPkgInfo and in data types referenced from it shall be supported by the NFVO in the filter expression. ") @Valid @RequestParam(value = "filter", required = false) String filter,@ApiParam(value = "Include all complex attributes in the response. See clause 5.3 of ETSI GS NFV SOL 013 for details. The NFVO shall support this parameter. ") @Valid @RequestParam(value = "all_fields", required = false) String allFields,@ApiParam(value = "Complex attributes to be included into the response. See clause 5.3 of ETSI GS NFV SOL 013 for details. The NFVO should support this parameter. ") @Valid @RequestParam(value = "fields", required = false) String fields,@ApiParam(value = "Complex attributes to be excluded from the response. See clause 5.3 of ETSI GS NFV SOL 013 for details. The NFVO should support this parameter. ") @Valid @RequestParam(value = "exclude_fields", required = false) String excludeFields,@ApiParam(value = "Indicates to exclude the following complex attributes from the response. See clause 5.3 of ETSI GS NFV-SOL 013 for details. The NFVO shall support this parameter. The following attributes shall be excluded from the VnfPkgInfo structure in the response body if this parameter is provided, or none of the parameters \"all_fields,\" \"fields\", \"exclude_fields\", \"exclude_default\" are provided: - softwareImages - additionalArtifacts - userDefinedData - checksum - onboardingFailureDetails ") @Valid @RequestParam(value = "exclude_default", required = false) String excludeDefault,@ApiParam(value = "Marker to obtain the next page of a paged response. Shall be supported by the NFVO if the NFVO supports alternative 2 (paging) according to clause 5.4.2.1 of ETSI GS NFV SOL 013 for this resource. ") @Valid @RequestParam(value = "nextpage_opaque_marker", required = false) String nextpageOpaqueMarker) {
        String a = request.getHeader("Accept");
        if (a != null && a.contains("application/json")) {
            try {
                return new ResponseEntity<>(objectMapper.readValue("[ {  \"VnfPkgInfo\" : {    \"packageSecurityOption\" : \"OPTION_1\",    \"vnfProductName\" : \"vnfProductName\",    \"signingCertificate\" : \"signingCertificate\",    \"vnfdVersion\" : \"vnfdVersion\",    \"vnfProvider\" : \"vnfProvider\",    \"vnfmInfo\" : [ \"vnfmInfo\", \"vnfmInfo\" ],    \"_links\" : {      \"vnfd\" : {        \"href\" : \"http://example.com/aeiou\"      },      \"self\" : {        \"href\" : \"http://example.com/aeiou\"      },      \"packageContent\" : {        \"href\" : \"http://example.com/aeiou\"      }    },    \"vnfdId\" : \"vnfdId\",    \"additionalArtifacts\" : [ {      \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",      \"metadata\" : \"{}\",      \"isEncrypted\" : true,      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"artifactPath\" : \"artifactPath\",      \"artifactClassification\" : \"HISTORY\",      \"artifactURI\" : \"http://example.com/aeiou\"    }, {      \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",      \"metadata\" : \"{}\",      \"isEncrypted\" : true,      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"artifactPath\" : \"artifactPath\",      \"artifactClassification\" : \"HISTORY\",      \"artifactURI\" : \"http://example.com/aeiou\"    } ],    \"usageState\" : \"IN_USE\",    \"onboardingFailureDetails\" : {      \"instance\" : \"instance\",      \"detail\" : \"detail\",      \"type\" : \"type\",      \"title\" : \"title\",      \"status\" : 5    },    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"softwareImages\" : [ {      \"imagePath\" : \"imagePath\",      \"version\" : \"version\",      \"minDisk\" : 0,      \"createdAt\" : \"\",      \"size\" : 0,      \"provider\" : \"provider\",      \"isEncrypted\" : true,      \"minRam\" : 0,      \"name\" : \"name\",      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"containerFormat\" : \"AKI\",      \"id\" : \"id\",      \"diskFormat\" : \"AKI\",      \"userMetadata\" : \"{}\"    }, {      \"imagePath\" : \"imagePath\",      \"version\" : \"version\",      \"minDisk\" : 0,      \"createdAt\" : \"\",      \"size\" : 0,      \"provider\" : \"provider\",      \"isEncrypted\" : true,      \"minRam\" : 0,      \"name\" : \"name\",      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"containerFormat\" : \"AKI\",      \"id\" : \"id\",      \"diskFormat\" : \"AKI\",      \"userMetadata\" : \"{}\"    } ],    \"id\" : \"id\",    \"operationalState\" : \"ENABLED\",    \"onboardingState\" : \"CREATED\",    \"compatibleSpecificationVersions\" : \"compatibleSpecificationVersions\",    \"vnfSoftwareVersion\" : \"vnfSoftwareVersion\",    \"userDefinedData\" : \"{}\"  }}, {  \"VnfPkgInfo\" : {    \"packageSecurityOption\" : \"OPTION_1\",    \"vnfProductName\" : \"vnfProductName\",    \"signingCertificate\" : \"signingCertificate\",    \"vnfdVersion\" : \"vnfdVersion\",    \"vnfProvider\" : \"vnfProvider\",    \"vnfmInfo\" : [ \"vnfmInfo\", \"vnfmInfo\" ],    \"_links\" : {      \"vnfd\" : {        \"href\" : \"http://example.com/aeiou\"      },      \"self\" : {        \"href\" : \"http://example.com/aeiou\"      },      \"packageContent\" : {        \"href\" : \"http://example.com/aeiou\"      }    },    \"vnfdId\" : \"vnfdId\",    \"additionalArtifacts\" : [ {      \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",      \"metadata\" : \"{}\",      \"isEncrypted\" : true,      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"artifactPath\" : \"artifactPath\",      \"artifactClassification\" : \"HISTORY\",      \"artifactURI\" : \"http://example.com/aeiou\"    }, {      \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",      \"metadata\" : \"{}\",      \"isEncrypted\" : true,      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"artifactPath\" : \"artifactPath\",      \"artifactClassification\" : \"HISTORY\",      \"artifactURI\" : \"http://example.com/aeiou\"    } ],    \"usageState\" : \"IN_USE\",    \"onboardingFailureDetails\" : {      \"instance\" : \"instance\",      \"detail\" : \"detail\",      \"type\" : \"type\",      \"title\" : \"title\",      \"status\" : 5    },    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"softwareImages\" : [ {      \"imagePath\" : \"imagePath\",      \"version\" : \"version\",      \"minDisk\" : 0,      \"createdAt\" : \"\",      \"size\" : 0,      \"provider\" : \"provider\",      \"isEncrypted\" : true,      \"minRam\" : 0,      \"name\" : \"name\",      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"containerFormat\" : \"AKI\",      \"id\" : \"id\",      \"diskFormat\" : \"AKI\",      \"userMetadata\" : \"{}\"    }, {      \"imagePath\" : \"imagePath\",      \"version\" : \"version\",      \"minDisk\" : 0,      \"createdAt\" : \"\",      \"size\" : 0,      \"provider\" : \"provider\",      \"isEncrypted\" : true,      \"minRam\" : 0,      \"name\" : \"name\",      \"checksum\" : {        \"hash\" : \"hash\",        \"algorithm\" : \"algorithm\"      },      \"containerFormat\" : \"AKI\",      \"id\" : \"id\",      \"diskFormat\" : \"AKI\",      \"userMetadata\" : \"{}\"    } ],    \"id\" : \"id\",    \"operationalState\" : \"ENABLED\",    \"onboardingState\" : \"CREATED\",    \"compatibleSpecificationVersions\" : \"compatibleSpecificationVersions\",    \"vnfSoftwareVersion\" : \"vnfSoftwareVersion\",    \"userDefinedData\" : \"{}\"  }} ]", List.class), HttpStatus.NOT_IMPLEMENTED);
            } catch (IOException e) {
                log.error("Couldn't serialize response for content type application/json", e);
                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<VnfPackagesVnfPkgInfo> vnfPackagesPost(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Content-Types that are acceptable for the response. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The MIME type of the body of the request. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Content-Type", required=true) String contentType,@ApiParam(value = "IndividualVNF package resource creation parameters, as defined in clause 9.5.2.2 " ,required=true )  @Valid @RequestBody Body body,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String a = request.getHeader("Accept");
        if (a != null && a.contains("application/json")) {
            try {
                return new ResponseEntity<VnfPackagesVnfPkgInfo>(objectMapper.readValue("{  \"packageSecurityOption\" : \"OPTION_1\",  \"vnfProductName\" : \"vnfProductName\",  \"signingCertificate\" : \"signingCertificate\",  \"vnfdVersion\" : \"vnfdVersion\",  \"vnfProvider\" : \"vnfProvider\",  \"vnfmInfo\" : [ \"vnfmInfo\", \"vnfmInfo\" ],  \"_links\" : {    \"vnfd\" : {      \"href\" : \"http://example.com/aeiou\"    },    \"self\" : {      \"href\" : \"http://example.com/aeiou\"    },    \"packageContent\" : {      \"href\" : \"http://example.com/aeiou\"    }  },  \"vnfdId\" : \"vnfdId\",  \"additionalArtifacts\" : [ {    \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",    \"metadata\" : \"{}\",    \"isEncrypted\" : true,    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"artifactPath\" : \"artifactPath\",    \"artifactClassification\" : \"HISTORY\",    \"artifactURI\" : \"http://example.com/aeiou\"  }, {    \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",    \"metadata\" : \"{}\",    \"isEncrypted\" : true,    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"artifactPath\" : \"artifactPath\",    \"artifactClassification\" : \"HISTORY\",    \"artifactURI\" : \"http://example.com/aeiou\"  } ],  \"usageState\" : \"IN_USE\",  \"onboardingFailureDetails\" : {    \"instance\" : \"instance\",    \"detail\" : \"detail\",    \"type\" : \"type\",    \"title\" : \"title\",    \"status\" : 5  },  \"checksum\" : {    \"hash\" : \"hash\",    \"algorithm\" : \"algorithm\"  },  \"softwareImages\" : [ {    \"imagePath\" : \"imagePath\",    \"version\" : \"version\",    \"minDisk\" : 0,    \"createdAt\" : \"\",    \"size\" : 0,    \"provider\" : \"provider\",    \"isEncrypted\" : true,    \"minRam\" : 0,    \"name\" : \"name\",    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"containerFormat\" : \"AKI\",    \"id\" : \"id\",    \"diskFormat\" : \"AKI\",    \"userMetadata\" : \"{}\"  }, {    \"imagePath\" : \"imagePath\",    \"version\" : \"version\",    \"minDisk\" : 0,    \"createdAt\" : \"\",    \"size\" : 0,    \"provider\" : \"provider\",    \"isEncrypted\" : true,    \"minRam\" : 0,    \"name\" : \"name\",    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"containerFormat\" : \"AKI\",    \"id\" : \"id\",    \"diskFormat\" : \"AKI\",    \"userMetadata\" : \"{}\"  } ],  \"id\" : \"id\",  \"operationalState\" : \"ENABLED\",  \"onboardingState\" : \"CREATED\",  \"compatibleSpecificationVersions\" : \"compatibleSpecificationVersions\",  \"vnfSoftwareVersion\" : \"vnfSoftwareVersion\",  \"userDefinedData\" : \"{}\"}", VnfPackagesVnfPkgInfo.class), HttpStatus.NOT_IMPLEMENTED);
            } catch (IOException e) {
                log.error("Couldn't serialize response for content type application/json", e);
                return new ResponseEntity<VnfPackagesVnfPkgInfo>(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        return new ResponseEntity<VnfPackagesVnfPkgInfo>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdArtifactsArtifactPathGet(@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. This identifier can be retrieved from the \"vnfPkgId\" attribute in the VnfPackageOnboardingNotification or VnfPackageChangeNotification. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "For an artifact contained as a file in the VNF package, this variable shall contain a sequence of one or path segments representing the path of the artifact within the VNF package, relative to the root of the package. See note 3. EXAMPLE: foo/bar/m%40ster.sh For an external artifact represented as a URI in the VNF package manifest, this variable shall contain a sequence of one or more path segments as synthesized by the NFVO (see clause 9.5.3.3), representing this artifact. See note 2 and note 3 ",required=true) @PathVariable("artifactPath") String artifactPath,@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true) @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "The request may contain a \"Range\" HTTP header to obtain single range of bytes from the VNF package file. This can be used to continue an aborted transmission. If the NFVO does not support range requests, it should return the whole file with a 200 OK response instead. " ) @RequestHeader(value="Range", required=false) String range,@ApiParam(value = "If this parameter is provided, the NFVO shall return the artifact and related security information (such as signature and optional certificate) in a ZIP archive. If this parameter is not given, the NFVO shall provide only a copy of the artifact file. This URI query parameter is a flag, i.e. it shall have no value. The NFVO shall support this parameter. ") @Valid @RequestParam(value = "include_signatures", required = false) String includeSignatures) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdArtifactsGet(@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. This identifier can be retrieved from the \"vnfPkgId\" attribute in the VnfPackageOnboardingNotification or VnfPackageChangeNotification. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true, allowableValues="application/zip") @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "The request may contain a \"Range\" HTTP header to obtain single range of bytes from the archive containing the artifacts. This can be used to continue an aborted transmission. If the \"Range\" header is present in the request and the NFVO does not support responding to range requests with a 206 response, it shall return a 200 OK response instead as defined below. " ) @RequestHeader(value="Range", required=false) String range,@ApiParam(value = "If this parameter is provided, the NFVO shall include in the ZIP archive the individual signatures and, if provided, related certificates for the included artifacts, in the format in which they are provided in the VNF package. If this parameter is not given, the NFVO shall only provide copies of the artifact files. This URI query parameter is a flag, i.e. it shall have no value. The NFVO shall support this parameter. ") @Valid @RequestParam(value = "include_signatures", required = false) String includeSignatures,@ApiParam(value = "Flag (i.e. parameter without value) that instructs the NFVO to exclude the set of additional MANO artifacts (i.e. those that are not images) from the response payload body. The NFVO shall support this parameter. The VNFM may supply this parameter. ") @Valid @RequestParam(value = "exclude_all_mano_artifacts", required = false) String excludeAllManoArtifacts,@ApiParam(value = "Flag (i.e. parameter without value) that instructs the NFVO to exclude the set of non-MANO artifacts from the response payload body. The NFVO shall support this parameter. The VNFM may supply this parameter. ") @Valid @RequestParam(value = "exclude_all_non_mano_artifacts", required = false) String excludeAllNonManoArtifacts,@ApiParam(value = "Comma-separated list of non-MANO artifact set identifiers for which the artifacts are to be included in the response body. The NFVO should support this parameter. If the NFVO does not support this parameter, it shall ignore it, i.e. provide a response as if no parameter was provided. The VNFM may supply this parameter. ") @Valid @RequestParam(value = "select_non_mano_artifact_sets", required = false) String selectNonManoArtifactSets) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdDelete(@ApiParam(value = "Identifier of the VNF package. The identifier is allocated by the NFVO.   ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Object> vnfPackagesVnfPkgIdExtArtifactsAccessGet(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. This identifier can be retrieved from the resource referenced by the \"Location\" HTTP header in the response to a POST request creating a new Individual VNF package resource. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true) @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String a = request.getHeader("Accept");
        if (accept != null && accept.contains("application/json")) {
            try {
                return new ResponseEntity<Object>(objectMapper.readValue("\"\"", Object.class), HttpStatus.NOT_IMPLEMENTED);
            } catch (IOException e) {
                log.error("Couldn't serialize response for content type application/json", e);
                return new ResponseEntity<Object>(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        return new ResponseEntity<Object>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Object> vnfPackagesVnfPkgIdExtArtifactsAccessPut(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. This identifier can be retrieved from the resource referenced by the \"Location\" HTTP header in the response to a POST request creating a new Individual VNF package resource. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "The payload body contains the access configuration information based on which the NFVO can obtain the external VNF package artifact files. " ,required=true )  @Valid @RequestBody Body2 body,@ApiParam(value = "The MIME type of the body of the request. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Content-Type", required=true) String contentType,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String accept = request.getHeader("Accept");
        if (accept != null && accept.contains("application/json")) {
            try {
                return new ResponseEntity<Object>(objectMapper.readValue("\"\"", Object.class), HttpStatus.NOT_IMPLEMENTED);
            } catch (IOException e) {
                log.error("Couldn't serialize response for content type application/json", e);
                return new ResponseEntity<Object>(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        return new ResponseEntity<Object>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<VnfPackagesVnfPkgInfo> vnfPackagesVnfPkgIdGet(@ApiParam(value = "Identifier of the VNF package. The identifier is allocated by the NFVO.   ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Content-Types that are acceptable for the response. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String a = request.getHeader("Accept");
        if (accept != null && accept.contains("application/json")) {
            try {
                return new ResponseEntity<VnfPackagesVnfPkgInfo>(objectMapper.readValue("{  \"packageSecurityOption\" : \"OPTION_1\",  \"vnfProductName\" : \"vnfProductName\",  \"signingCertificate\" : \"signingCertificate\",  \"vnfdVersion\" : \"vnfdVersion\",  \"vnfProvider\" : \"vnfProvider\",  \"vnfmInfo\" : [ \"vnfmInfo\", \"vnfmInfo\" ],  \"_links\" : {    \"vnfd\" : {      \"href\" : \"http://example.com/aeiou\"    },    \"self\" : {      \"href\" : \"http://example.com/aeiou\"    },    \"packageContent\" : {      \"href\" : \"http://example.com/aeiou\"    }  },  \"vnfdId\" : \"vnfdId\",  \"additionalArtifacts\" : [ {    \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",    \"metadata\" : \"{}\",    \"isEncrypted\" : true,    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"artifactPath\" : \"artifactPath\",    \"artifactClassification\" : \"HISTORY\",    \"artifactURI\" : \"http://example.com/aeiou\"  }, {    \"nonManoArtifactSetId\" : \"nonManoArtifactSetId\",    \"metadata\" : \"{}\",    \"isEncrypted\" : true,    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"artifactPath\" : \"artifactPath\",    \"artifactClassification\" : \"HISTORY\",    \"artifactURI\" : \"http://example.com/aeiou\"  } ],  \"usageState\" : \"IN_USE\",  \"onboardingFailureDetails\" : {    \"instance\" : \"instance\",    \"detail\" : \"detail\",    \"type\" : \"type\",    \"title\" : \"title\",    \"status\" : 5  },  \"checksum\" : {    \"hash\" : \"hash\",    \"algorithm\" : \"algorithm\"  },  \"softwareImages\" : [ {    \"imagePath\" : \"imagePath\",    \"version\" : \"version\",    \"minDisk\" : 0,    \"createdAt\" : \"\",    \"size\" : 0,    \"provider\" : \"provider\",    \"isEncrypted\" : true,    \"minRam\" : 0,    \"name\" : \"name\",    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"containerFormat\" : \"AKI\",    \"id\" : \"id\",    \"diskFormat\" : \"AKI\",    \"userMetadata\" : \"{}\"  }, {    \"imagePath\" : \"imagePath\",    \"version\" : \"version\",    \"minDisk\" : 0,    \"createdAt\" : \"\",    \"size\" : 0,    \"provider\" : \"provider\",    \"isEncrypted\" : true,    \"minRam\" : 0,    \"name\" : \"name\",    \"checksum\" : {      \"hash\" : \"hash\",      \"algorithm\" : \"algorithm\"    },    \"containerFormat\" : \"AKI\",    \"id\" : \"id\",    \"diskFormat\" : \"AKI\",    \"userMetadata\" : \"{}\"  } ],  \"id\" : \"id\",  \"operationalState\" : \"ENABLED\",  \"onboardingState\" : \"CREATED\",  \"compatibleSpecificationVersions\" : \"compatibleSpecificationVersions\",  \"vnfSoftwareVersion\" : \"vnfSoftwareVersion\",  \"userDefinedData\" : \"{}\"}", VnfPackagesVnfPkgInfo.class), HttpStatus.NOT_IMPLEMENTED);
            } catch (IOException e) {
                log.error("Couldn't serialize response for content type application/json", e);
                return new ResponseEntity<VnfPackagesVnfPkgInfo>(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        return new ResponseEntity<VnfPackagesVnfPkgInfo>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdManifestGet(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. This identifier can be retrieved from the \"vnfPkgId\" attribute in the VnfPackageOnboardingNotification or VnfPackageChangeNotification. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true, allowableValues="text/plain, application/zip") @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "If this parameter is provided, the NFVO shall return the manifest and related security information (such as certificate) in a ZIP archive. If this parameter is not given, the NFVO shall provide only a copy of the manifest file. This URI query parameter is a flag, i.e. it shall have no value. The NFVO shall support this parameter. ") @Valid @RequestParam(value = "include_signatures", required = false) String includeSignatures) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdPackageContentGet(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true, allowableValues="application/zip") @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "The request may contain a \"Range\" HTTP header to obtain single range of bytes from the VNF package file. This can be used to continue an aborted transmission. If the NFVO does not support range requests, it should return the whole file with a 200 OK response instead. " ) @RequestHeader(value="Range", required=false) String range) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdPackageContentPut(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true, allowableValues="application/zip") @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "The payload body contains a ZIP file that represents the VNF package. The \"Content-Type\" HTTP header shall be set according to the type of the file, i.e. to \"application/zip\" for a VNF Package as defined in ETSI GS NFV-SOL 004. ") @Valid @RequestPart(value="file", required=false) MultipartFile file) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdPackageContentUploadFromUriPost(@ApiParam(value = "Content-Types that are acceptable for the response. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the VNF package. The identifier is allocated by the NFVO. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "The payload body contains the address information based on which the NFVO can obtain the content of the VNF package. " ,required=true )  @Valid @RequestBody Body3 body,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235 " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Object> vnfPackagesVnfPkgIdPatch(@ApiParam(value = "Identifier of the VNF package. The identifier is allocated by the NFVO.   ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Parameters for VNF package information modifications. " ,required=true )  @Valid @RequestBody Body1 body,@ApiParam(value = "The MIME type of the body of the request. Reference: IETF RFC 7231 " ,required=true) @RequestHeader(value="Content-Type", required=true) String contentType,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization) {
        String a = request.getHeader("Accept");
        if (a != null && a.contains("application/json")) {
            try {
                return new ResponseEntity<Object>(objectMapper.readValue("\"\"", Object.class), HttpStatus.NOT_IMPLEMENTED);
            } catch (IOException e) {
                log.error("Couldn't serialize response for content type application/json", e);
                return new ResponseEntity<Object>(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        return new ResponseEntity<Object>(HttpStatus.NOT_IMPLEMENTED);
    }

    public ResponseEntity<Void> vnfPackagesVnfPkgIdVnfdGet(@ApiParam(value = "Version of the API requested to use when responding to this request. " ,required=true) @RequestHeader(value="Version", required=true) String version,@ApiParam(value = "Identifier of the on-boarded VNF package. The identifier is allocated by the NFVO. This identifier can be retrieved from the \"vnfPkgId\" attribute in the VnfPackageOnboardingNotification or VnfPackageChangeNotification. ",required=true) @PathVariable("vnfPkgId") String vnfPkgId,@ApiParam(value = "Content-Types that are acceptable for the response. " ,required=true, allowableValues="text/plain, application/zip") @RequestHeader(value="Accept", required=true) String accept,@ApiParam(value = "The authorization token for the request. Reference: IETF RFC 7235. " ) @RequestHeader(value="Authorization", required=false) String authorization,@ApiParam(value = "If this parameter is provided, the NFVO shall include in the ZIP archive the security information as specified above. This URI query parameter is a flag, i.e. it shall have no value. The NFVO shall support this parameter. ") @Valid @RequestParam(value = "include_signatures", required = false) String includeSignatures) {
        String a = request.getHeader("Accept");
        return new ResponseEntity<Void>(HttpStatus.NOT_IMPLEMENTED);
    }

	@Override
	public ObjectMapper getObjectMapper() {
		// TODO Auto-generated method stub
		return null;
	}

}
